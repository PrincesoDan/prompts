{    "prompt": "Smart contract source code: 
    pub mod contract { 
    use soroban_sdk::{contractimpl, Env}; 
    pub struct HelloContract; 
    #[contractimpl] 
    impl HelloContract { 
        pub fn say_hello(env: Env, to: String) -> String { 
            format!(\\\"Hello, {}!\\\", to) 
        } 
    } 
    }",    "completion": "This code defines a simple smart contract with a `say_hello` function."}
    "completion": "Test case: 

      #[cfg(test)] 

      mod test { 

          use super::*; 

          use soroban_sdk::{Env}; 

          #[test] 

          fn test_say_hello() { 

              let env = Env::default(); 

              let contract = HelloContract; 

              let result = contract.say_hello(env.clone(), \"World\".to_string()); 

              assert_eq!(result, \"Hello, World!\"); 

          } 

      }"
  }
  
  {
    "prompt": "//! This a basic multi-sig account contract that with a customizable per-token
  //! authorization policy.
  //!
  //! This demonstrates how to build the account contracts and how to use the
  //! authorization context in order to implement custom authorization policies
  //! that would govern all the account contract interactions.
  #![no_std]
  
  use soroban_sdk::{
      auth::{Context, CustomAccountInterface},
      contract, contracterror, contractimpl, contracttype,
      crypto::Hash,
      symbol_short, Address, BytesN, Env, Map, Symbol, TryIntoVal, Vec,
  };
  #[contract]
  struct AccountContract;
  
  #[contracttype]
  #[derive(Clone)]
  pub struct AccSignature {
      pub public_key: BytesN<32>,
      pub signature: BytesN<64>,
  }
  
  #[contracttype]
  #[derive(Clone)]
  enum DataKey {
      SignerCnt,
      Signer(BytesN<32>),
      SpendLimit(Address),
  }
  
  #[contracterror]
  #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
  #[repr(u32)]
  pub enum AccError {
      NotEnoughSigners = 1,
      NegativeAmount = 2,
      BadSignatureOrder = 3,
      UnknownSigner = 4,
      InvalidContext = 5,
  }
  
  const TRANSFER_FN: Symbol = symbol_short!("transfer");
  
  #[contractimpl]
  impl AccountContract {
      // Initialize the contract with a list of ed25519 public key ('signers').
      pub fn init(env: Env, signers: Vec<BytesN<32>>) {
          // In reality this would need some additional validation on signers
          // (deduplication etc.).
          for signer in signers.iter() {
              env.storage().instance().set(&DataKey::Signer(signer), &());
          }
          env.storage()
              .instance()
              .set(&DataKey::SignerCnt, &signers.len());
      }
  
      // Adds a limit on any token transfers that aren't signed by every signer.
      pub fn add_limit(env: Env, token: Address, limit: i128) {
          // The current contract address is the account contract address and has
          // the same semantics for `require_auth` call as any other account
          // contract address.
          // Note, that if a contract *invokes* another contract, then it would
          // authorize the call on its own behalf and that wouldn't require any
          // user-side verification.
          env.current_contract_address().require_auth();
          env.storage()
              .instance()
              .set(&DataKey::SpendLimit(token), &limit);
      }
  }
  
  #[contractimpl]
  impl CustomAccountInterface for AccountContract {
      type Signature = Vec<AccSignature>;
      type Error = AccError;
  
      // This is the 'entry point' of the account contract and every account
      // contract has to implement it. `require_auth` calls for the Address of
      // this contract will result in calling this `__check_auth` function with
      // the appropriate arguments.
      //
      // This should return `()` if authentication and authorization checks have
      // been passed and return an error (or panic) otherwise.
      //
      // `__check_auth` takes the payload that needed to be signed, arbitrarily
      // typed signatures (`Vec<AccSignature>` contract type here) and authorization
      // context that contains all the invocations that this call tries to verify.
      //
      // `__check_auth` has to authenticate the signatures. It also may use
      // `auth_context` to implement additional authorization policies (like token
      // spend limits here).
      //
      // Soroban host guarantees that `__check_auth` is only being called during
      // `require_auth` verification and hence this may mutate its own state
      // without the need for additional authorization (for example, this could
      // store per-time-period token spend limits instead of just enforcing the
      // limit per contract call).
      //
      // Note, that `__check_auth` function shouldn't call `require_auth` on the
      // contract's own address in order to avoid infinite recursion.
      #[allow(non_snake_case)]
      fn __check_auth(
          env: Env,
          signature_payload: Hash<32>,
          signatures: Vec<AccSignature>,
          auth_context: Vec<Context>,
      ) -> Result<(), AccError> {
          // Perform authentication.
          authenticate(&env, &signature_payload, &signatures)?;
  
          let tot_signers: u32 = env
              .storage()
              .instance()
              .get::<_, u32>(&DataKey::SignerCnt)
              .unwrap();
          let all_signed = tot_signers == signatures.len();
  
          let curr_contract = env.current_contract_address();
  
          // This is a map for tracking the token spend limits per token. This
          // makes sure that if e.g. multiple `transfer` calls are being authorized
          // for the same token we still respect the limit for the total
          // transferred amount (and not the 'per-call' limits).
          let mut spend_left_per_token = Map::<Address, i128>::new(&env);
          // Verify the authorization policy.
          for context in auth_context.iter() {
              verify_authorization_policy(
                  &env,
                  &context,
                  &curr_contract,
                  all_signed,
                  &mut spend_left_per_token,
              )?;
          }
          Ok(())
      }
  }
  
  fn authenticate(
      env: &Env,
      signature_payload: &Hash<32>,
      signatures: &Vec<AccSignature>,
  ) -> Result<(), AccError> {
      for i in 0..signatures.len() {
          let signature = signatures.get_unchecked(i);
          if i > 0 {
              let prev_signature = signatures.get_unchecked(i - 1);
              if prev_signature.public_key >= signature.public_key {
                  return Err(AccError::BadSignatureOrder);
              }
          }
          if !env
              .storage()
              .instance()
              .has(&DataKey::Signer(signature.public_key.clone()))
          {
              return Err(AccError::UnknownSigner);
          }
          env.crypto().ed25519_verify(
              &signature.public_key,
              &signature_payload.clone().into(),
              &signature.signature,
          );
      }
      Ok(())
  }
  
  fn verify_authorization_policy(
      env: &Env,
      context: &Context,
      curr_contract: &Address,
      all_signed: bool,
      spend_left_per_token: &mut Map<Address, i128>,
  ) -> Result<(), AccError> {
      let contract_context = match context {
          Context::Contract(c) => {
              if &c.contract == curr_contract {
                  if !all_signed {
                      return Err(AccError::NotEnoughSigners);
                  }
              }
              c
          }
          Context::CreateContractHostFn(_) => return Err(AccError::InvalidContext),
      };
      // For the account control every signer must sign the invocation.
  
      // Otherwise, we're only interested in functions that spend tokens.
      if contract_context.fn_name != TRANSFER_FN
          && contract_context.fn_name != Symbol::new(env, "approve")
      {
          return Ok(());
      }
  
      let spend_left: Option<i128> =
          if let Some(spend_left) = spend_left_per_token.get(contract_context.contract.clone()) {
              Some(spend_left)
          } else if let Some(limit_left) = env
              .storage()
              .instance()
              .get::<_, i128>(&DataKey::SpendLimit(contract_context.contract.clone()))
          {
              Some(limit_left)
          } else {
              None
          };
  
      // 'None' means that the contract is outside of the policy.
      if let Some(spend_left) = spend_left {
          // 'amount' is the third argument in both `approve` and `transfer`.
          // If the contract has a different signature, it's safer to panic
          // here, as it's expected to have the standard interface.
          let spent: i128 = contract_context
              .args
              .get(2)
              .unwrap()
              .try_into_val(env)
              .unwrap();
          if spent < 0 {
              return Err(AccError::NegativeAmount);
          }
          if !all_signed && spent > spend_left {
              return Err(AccError::NotEnoughSigners);
          }
          spend_left_per_token.set(contract_context.contract.clone(), spend_left - spent);
      }
      Ok(())
  }
  
  mod test;",
    "completion": "#![cfg(test)]
  extern crate std;
  
  use ed25519_dalek::Keypair;
  use ed25519_dalek::Signer;
  use rand::thread_rng;
  use soroban_sdk::auth::ContractContext;
  use soroban_sdk::symbol_short;
  use soroban_sdk::testutils::Address as _;
  use soroban_sdk::testutils::AuthorizedFunction;
  use soroban_sdk::testutils::AuthorizedInvocation;
  use soroban_sdk::Val;
  use soroban_sdk::{
      auth::Context, testutils::BytesN as _, vec, Address, BytesN, Env, IntoVal, Symbol,
  };
  
  use crate::AccError;
  use crate::{AccSignature, AccountContract, AccountContractClient};
  
  fn generate_keypair() -> Keypair {
      Keypair::generate(&mut thread_rng())
  }
  
  fn signer_public_key(e: &Env, signer: &Keypair) -> BytesN<32> {
      signer.public.to_bytes().into_val(e)
  }
  
  fn create_account_contract(e: &Env) -> AccountContractClient {
      AccountContractClient::new(e, &e.register_contract(None, AccountContract {}))
  }
  
  fn sign(e: &Env, signer: &Keypair, payload: &BytesN<32>) -> Val {
      AccSignature {
          public_key: signer_public_key(e, signer),
          signature: signer
              .sign(payload.to_array().as_slice())
              .to_bytes()
              .into_val(e),
      }
      .into_val(e)
  }
  
  fn token_auth_context(e: &Env, token_id: &Address, fn_name: Symbol, amount: i128) -> Context {
      Context::Contract(ContractContext {
          contract: token_id.clone(),
          fn_name,
          args: ((), (), amount).into_val(e),
      })
  }
  
  #[test]
  fn test_token_auth() {
      let env = Env::default();
      env.mock_all_auths();
  
      let account_contract = create_account_contract(&env);
  
      let mut signers = [generate_keypair(), generate_keypair()];
      if signers[0].public.as_bytes() > signers[1].public.as_bytes() {
          signers.swap(0, 1);
      }
      account_contract.init(&vec![
          &env,
          signer_public_key(&env, &signers[0]),
          signer_public_key(&env, &signers[1]),
      ]);
  
      let payload = BytesN::random(&env);
      let token = Address::generate(&env);
      // `__check_auth` can't be called directly, hence we need to use
      // `try_invoke_contract_check_auth` testing utility that emulates being
      // called by the Soroban host during a `require_auth` call.
      env.try_invoke_contract_check_auth::<AccError>(
          &account_contract.address,
          &payload,
          vec![&env, sign(&env, &signers[0], &payload)].into(),
          &vec![
              &env,
              token_auth_context(&env, &token, Symbol::new(&env, "transfer"), 1000),
          ],
      )
      .unwrap();
      env.try_invoke_contract_check_auth::<AccError>(
          &account_contract.address,
          &payload,
          vec![&env, sign(&env, &signers[0], &payload)].into(),
          &vec![
              &env,
              token_auth_context(&env, &token, Symbol::new(&env, "transfer"), 1000),
          ],
      )
      .unwrap();
  
      // Add a spend limit of 1000 per 1 signer.
      account_contract.add_limit(&token, &1000);
      // Verify that this call needs to be authorized.
  
      assert_eq!(
          env.auths(),
          std::vec![(
              account_contract.address.clone(),
              AuthorizedInvocation {
                  function: AuthorizedFunction::Contract((
                      account_contract.address.clone(),
                      symbol_short!("add_limit"),
                      (token.clone(), 1000_i128).into_val(&env),
                  )),
                  sub_invocations: std::vec![]
              }
          )]
      );
  
      // 1 signer no longer can perform the token operation that transfers more
      // than 1000 units.
      assert_eq!(
          env.try_invoke_contract_check_auth::<AccError>(
              &account_contract.address,
              &payload,
              vec![&env, sign(&env, &signers[0], &payload)].into(),
              &vec![
                  &env,
                  token_auth_context(&env, &token, Symbol::new(&env, "transfer"), 1001)
              ],
          )
          .err()
          .unwrap()
          .unwrap(),
          AccError::NotEnoughSigners
      );
      assert_eq!(
          env.try_invoke_contract_check_auth::<AccError>(
              &account_contract.address,
              &payload,
              vec![&env, sign(&env, &signers[0], &payload)].into(),
              &vec![
                  &env,
                  token_auth_context(&env, &token, Symbol::new(&env, "approve"), 1001)
              ],
          )
          .err()
          .unwrap()
          .unwrap(),
          AccError::NotEnoughSigners
      );
  
      // 1 signer can still transfer 1000 units.
      env.try_invoke_contract_check_auth::<AccError>(
          &account_contract.address,
          &payload,
          vec![&env, sign(&env, &signers[0], &payload)].into(),
          &vec![
              &env,
              token_auth_context(&env, &token, Symbol::new(&env, "approve"), 1000),
          ],
      )
      .unwrap();
      // 2 signers can transfer any amount of token.
      env.try_invoke_contract_check_auth::<AccError>(
          &account_contract.address,
          &payload,
          vec![
              &env,
              sign(&env, &signers[0], &payload),
              sign(&env, &signers[1], &payload),
          ]
          .into(),
          &vec![
              &env,
              token_auth_context(&env, &token, Symbol::new(&env, "transfer"), 10000),
          ],
      )
      .unwrap();
  }"
  }
  {
    "prompt": "#![no_std]
  use soroban_sdk::{contract, contractimpl, Env};
  
  extern crate alloc;
  
  #[contract]
  pub struct AllocContract;
  
  #[contractimpl]
  impl AllocContract {
      /// Allocates a temporary vector holding values (0..count), then computes and returns their sum.
      pub fn sum(_env: Env, count: u32) -> u32 {
          let mut v1 = alloc::vec![];
          (0..count).for_each(|i| v1.push(i));
  
          let mut sum = 0;
          for i in v1 {
              sum += i;
          }
  
          sum
      }
  }
  
  mod test;",
    "completion": "#![cfg(test)]
  
  use super::{AllocContract, AllocContractClient};
  use soroban_sdk::{testutils::Logs, Env};
  
  extern crate std;
  
  #[test]
  fn test() {
      let env = Env::default();
      let contract_id = env.register_contract(None, AllocContract);
      let client = AllocContractClient::new(&env, &contract_id);
      assert_eq!(client.sum(&1), 0);
      assert_eq!(client.sum(&2), 1);
      assert_eq!(client.sum(&5), 10);
  
      std::println!("{}", env.logs().all().join("\n"));
  }"
  }
  {
    "prompt": "//! This contract performs a batch of atomic token swaps between multiple
//! parties and does a simple price matching.
//! Parties don't need to know each other and also don't need to know their
//! signatures are used in this contract; they sign the `AtomicSwap` contract
//! invocation that guarantees that their token will be swapped with someone
//! while following the price limit.
//! This example demonstrates how authorized calls can be batched together.
#![no_std]

use soroban_sdk::{contract, contractimpl, contracttype, Address, Env, Vec};

mod atomic_swap {
    soroban_sdk::contractimport!(
        file = "../atomic_swap/target/wasm32-unknown-unknown/release/soroban_atomic_swap_contract.wasm"
    );}

#[derive(Clone)]
#[contracttype]
pub struct SwapSpec {
    pub address: Address,
    pub amount: i128,
    pub min_recv: i128,}

#[contract]
pub struct AtomicMultiSwapContract;

#[contractimpl]
impl AtomicMultiSwapContract {
    // Swap token A for token B atomically between the parties that want to
    // swap A->B and parties that want to swap B->A.
    // All the parties should have authorized the `swap` via `swap_contract`,
    // but they don't need to authorize `multi_swap` itself.
    pub fn multi_swap(
        env: Env,
        swap_contract: Address,
        token_a: Address,
        token_b: Address,
        swaps_a: Vec<SwapSpec>,
        swaps_b: Vec<SwapSpec>,
    ) {
        let mut swaps_b = swaps_b;
        let swap_client = atomic_swap::Client::new(&env, &swap_contract);
        for acc_a in swaps_a.iter() {
            for i in 0..swaps_b.len() {
                let acc_b = swaps_b.get(i).unwrap();

                if acc_a.amount >= acc_b.min_recv && acc_a.min_recv <= acc_b.amount {
                    // As this is a simple 'batching' contract, there is no need
                    // for all swaps to succeed, hence we handle the failures
                    // gracefully to try and clear as many swaps as possible.
                    if swap_client
                        .try_swap(
                            &acc_a.address,
                            &acc_b.address,
                            &token_a,
                            &token_b,
                            &acc_a.amount,
                            &acc_a.min_recv,
                            &acc_b.amount,
                            &acc_b.min_recv,
                        )
                        .is_ok()
                    {
                        swaps_b.remove(i);
                        break;
                    }
                }
            }
        }
    }

mod test;
",
    "completion": "#![cfg(test)]
extern crate std;

use super::*;
use assert_unordered::assert_eq_unordered;
use soroban_sdk::{
    symbol_short,
    testutils::{Address as _, AuthorizedFunction, AuthorizedInvocation},
    token, Address, Env, IntoVal,
};
use token::Client as TokenClient;
use token::StellarAssetClient as TokenAdminClient;

fn create_token_contract<'a>(e: &Env, admin: &Address) -> (TokenClient<'a>, TokenAdminClient<'a>) {
    let sac = e.register_stellar_asset_contract_v2(admin.clone());
    (
        token::Client::new(e, &sac.address()),
        token::StellarAssetClient::new(e, &sac.address()),
    )}

fn create_atomic_multiswap_contract(e: &Env) -> AtomicMultiSwapContractClient {
    AtomicMultiSwapContractClient::new(e, &e.register_contract(None, AtomicMultiSwapContract {}))}

#[test]
fn test_atomic_multi_swap() {
    let env = Env::default();
    env.mock_all_auths_allowing_non_root_auth();

    let swaps_a = [
        SwapSpec {
            address: Address::generate(&env),
            amount: 2000,
            min_recv: 290,
        },
        SwapSpec {
            address: Address::generate(&env),
            amount: 3000,
            min_recv: 350,
        },
        SwapSpec {
            address: Address::generate(&env),
            amount: 4000,
            min_recv: 301,
        },
    ];
    let swaps_b = [
        SwapSpec {
            address: Address::generate(&env),
            amount: 300,
            min_recv: 2100,
        },
        SwapSpec {
            address: Address::generate(&env),
            amount: 295,
            min_recv: 1950,
        },
        SwapSpec {
            address: Address::generate(&env),
            amount: 400,
            min_recv: 2900,
        },
    ];

    let token_admin = Address::generate(&env);

    let (token_a, token_a_admin) = create_token_contract(&env, &token_admin);
    let (token_b, token_b_admin) = create_token_contract(&env, &token_admin);
    token_a_admin.mint(&swaps_a[0].address, &2000);
    token_a_admin.mint(&swaps_a[1].address, &3000);
    token_a_admin.mint(&swaps_a[2].address, &4000);

    token_b_admin.mint(&swaps_b[0].address, &300);
    token_b_admin.mint(&swaps_b[1].address, &295);
    token_b_admin.mint(&swaps_b[2].address, &400);

    let contract = create_atomic_multiswap_contract(&env);

    let swap_contract_id = env.register_contract_wasm(None, atomic_swap::WASM);

    contract.multi_swap(
        &swap_contract_id,
        &token_a.address,
        &token_b.address,
        &Vec::from_array(&env, swaps_a.clone()),
        &Vec::from_array(&env, swaps_b.clone()),
    );

    // Check that only 4 swaps were authorized and accounts A[0] and B[1] didn't
    // authorize anything. Their swaps still can be cleared via a new contract
    // call with the correct arguments.
    // Notice, that `swap` authorizations are recorded - they're the top-level
    // authorized calls, even though `multi_swap` was the overall top-level
    // invocation.
    assert_eq_unordered!(
        env.auths(),
        std::vec![
            (
                swaps_a[0].address.clone(),
                AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        swap_contract_id.clone(),
                        symbol_short!("swap"),
                        (
                            token_a.address.clone(),
                            token_b.address.clone(),
                            2000_i128,
                            290_i128
                        )
                            .into_val(&env),
                    )),
                    sub_invocations: std::vec![AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token_a.address.clone(),
                            symbol_short!("transfer"),
                            (
                                swaps_a[0].address.clone(),
                                swap_contract_id.clone(),
                                2000_i128,
                            )
                                .into_val(&env),
                        )),
                        sub_invocations: std::vec![]
                    }]
                }
            ),
            (
                swaps_a[1].address.clone(),
                AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        swap_contract_id.clone(),
                        symbol_short!("swap"),
                        (
                            token_a.address.clone(),
                            token_b.address.clone(),
                            3000_i128,
                            350_i128
                        )
                            .into_val(&env),
                    )),
                    sub_invocations: std::vec![AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token_a.address.clone(),
                            symbol_short!("transfer"),
                            (
                                swaps_a[1].address.clone(),
                                swap_contract_id.clone(),
                                3000_i128,
                            )
                                .into_val(&env),
                        )),
                        sub_invocations: std::vec![]
                    }]
                }
            ),
            (
                swaps_b[1].address.clone(),
                AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        swap_contract_id.clone(),
                        symbol_short!("swap"),
                        (
                            token_b.address.clone(),
                            token_a.address.clone(),
                            295_i128,
                            1950_i128,
                        )
                            .into_val(&env),
                    )),
                    sub_invocations: std::vec![AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token_b.address.clone(),
                            symbol_short!("transfer"),
                            (
                                swaps_b[1].address.clone(),
                                swap_contract_id.clone(),
                                295_i128,
                            )
                                .into_val(&env),
                        )),
                        sub_invocations: std::vec![]
                    }]
                }
            ),
            (
                swaps_b[2].address.clone(),
                AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        swap_contract_id.clone(),
                        symbol_short!("swap"),
                        (
                            token_b.address.clone(),
                            token_a.address.clone(),
                            400_i128,
                            2900_i128,
                        )
                            .into_val(&env),
                    )),
                    sub_invocations: std::vec![AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token_b.address.clone(),
                            symbol_short!("transfer"),
                            (
                                swaps_b[2].address.clone(),
                                swap_contract_id.clone(),
                                400_i128,
                            )
                                .into_val(&env),
                        )),
                        sub_invocations: std::vec![]
                    }]
                }
            ),
        ]
    );
    // Balance has to be checked after the auth checks because auth is only
    // stored for the last invocation currently.
    assert_eq!(token_a.balance(&swaps_a[0].address), 50);
    assert_eq!(token_a.balance(&swaps_a[1].address), 100);
    assert_eq!(token_a.balance(&swaps_a[2].address), 4000);

    assert_eq!(token_a.balance(&swaps_b[0].address), 0);
    assert_eq!(token_a.balance(&swaps_b[1].address), 1950);
    assert_eq!(token_a.balance(&swaps_b[2].address), 2900);

    assert_eq!(token_b.balance(&swaps_a[0].address), 290);
    assert_eq!(token_b.balance(&swaps_a[1].address), 350);
    assert_eq!(token_b.balance(&swaps_a[2].address), 0);

    assert_eq!(token_b.balance(&swaps_b[0].address), 300);
    assert_eq!(token_b.balance(&swaps_b[1].address), 5);
    assert_eq!(token_b.balance(&swaps_b[2].address), 50);}

#[test]
fn test_multi_swap_with_duplicate_account() {
    let env = Env::default();
    env.mock_all_auths_allowing_non_root_auth();

    let address_a = Address::generate(&env);
    let address_b = Address::generate(&env);
    let swaps_a = [
        SwapSpec {
            address: address_a.clone(),
            amount: 1000,
            min_recv: 100,
        },
        SwapSpec {
            address: address_a.clone(),
            amount: 2000,
            min_recv: 190,
        },
    ];
    let swaps_b = [
        SwapSpec {
            address: address_b.clone(),
            amount: 101,
            min_recv: 1000,
        },
        SwapSpec {
            address: address_b.clone(),
            amount: 190,
            min_recv: 2000,
        },
    ];

    let token_admin = Address::generate(&env);

    let (token_a, token_a_admin) = create_token_contract(&env, &token_admin);
    let (token_b, token_b_admin) = create_token_contract(&env, &token_admin);
    token_a_admin.mint(&address_a, &3000);
    token_b_admin.mint(&address_b, &291);

    let contract = create_atomic_multiswap_contract(&env);

    let swap_contract_id = env.register_contract_wasm(None, atomic_swap::WASM);

    contract.multi_swap(
        &swap_contract_id,
        &token_a.address,
        &token_b.address,
        &Vec::from_array(&env, swaps_a.clone()),
        &Vec::from_array(&env, swaps_b.clone()),
    );

    // Notice that the same address may participate in multiple swaps. Separate
    // authorizations are recorded (and required on-chain) for every swap.
    assert_eq_unordered!(
        env.auths(),
        std::vec![
            (
                address_a.clone(),
                AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        swap_contract_id.clone(),
                        symbol_short!("swap"),
                        (
                            token_a.address.clone(),
                            token_b.address.clone(),
                            1000_i128,
                            100_i128
                        )
                            .into_val(&env),
                    )),
                    sub_invocations: std::vec![AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token_a.address.clone(),
                            symbol_short!("transfer"),
                            (address_a.clone(), swap_contract_id.clone(), 1000_i128,)
                                .into_val(&env),
                        )),
                        sub_invocations: std::vec![]
                    }]
                }
            ),
            (
                address_a.clone(),
                AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        swap_contract_id.clone(),
                        symbol_short!("swap"),
                        (
                            token_a.address.clone(),
                            token_b.address.clone(),
                            2000_i128,
                            190_i128
                        )
                            .into_val(&env),
                    )),
                    sub_invocations: std::vec![AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token_a.address.clone(),
                            symbol_short!("transfer"),
                            (address_a.clone(), swap_contract_id.clone(), 2000_i128,)
                                .into_val(&env),
                        )),
                        sub_invocations: std::vec![]
                    }]
                }
            ),
            (
                address_b.clone(),
                AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        swap_contract_id.clone(),
                        symbol_short!("swap"),
                        (
                            token_b.address.clone(),
                            token_a.address.clone(),
                            101_i128,
                            1000_i128
                        )
                            .into_val(&env),
                    )),
                    sub_invocations: std::vec![AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token_b.address.clone(),
                            symbol_short!("transfer"),
                            (address_b.clone(), swap_contract_id.clone(), 101_i128,).into_val(&env),
                        )),
                        sub_invocations: std::vec![]
                    }]
                }
            ),
            (
                address_b.clone(),
                AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        swap_contract_id.clone(),
                        symbol_short!("swap"),
                        (
                            token_b.address.clone(),
                            token_a.address.clone(),
                            190_i128,
                            2000_i128
                        )
                            .into_val(&env),
                    )),
                    sub_invocations: std::vec![AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token_b.address.clone(),
                            symbol_short!("transfer"),
                            (address_b.clone(), swap_contract_id.clone(), 190_i128,).into_val(&env),
                        )),
                        sub_invocations: std::vec![]
                    }]
                }
            ),
        ]
    );

    // Balance has to be checked after the auth checks because auth is only
    // stored for the last invocation currently.
    assert_eq!(token_a.balance(&address_a), 0);
    assert_eq!(token_a.balance(&address_b), 3000);

    assert_eq!(token_b.balance(&address_a), 290);
    assert_eq!(token_b.balance(&address_b), 1);}
"
  }

  {
    "prompt": "//! This contract performs an atomic token swap between two parties.
//! Parties don't need to know each other and their signatures may be matched
//! off-chain.
//! This example demonstrates how multi-party authorization can be implemented.
#![no_std]

use soroban_sdk::{contract, contractimpl, token, Address, Env, IntoVal};

#[contract]
pub struct AtomicSwapContract;

#[contractimpl]
impl AtomicSwapContract {
    // Swap token A for token B atomically. Settle for the minimum requested price
    // for each party (this is an arbitrary choice; both parties could have
    // received the full amount as well).
    pub fn swap(
        env: Env,
        a: Address,
        b: Address,
        token_a: Address,
        token_b: Address,
        amount_a: i128,
        min_b_for_a: i128,
        amount_b: i128,
        min_a_for_b: i128,
    ) {
        // Verify preconditions on the minimum price for both parties.
        if amount_b < min_b_for_a {
            panic!("not enough token B for token A");
        }
        if amount_a < min_a_for_b {
            panic!("not enough token A for token B");
        }
        // Require authorization for a subset of arguments specific to a party.
        // Notice, that arguments are symmetric - there is no difference between
        // `a` and `b` in the call and hence their signatures can be used
        // either for `a` or for `b` role.
        a.require_auth_for_args(
            (token_a.clone(), token_b.clone(), amount_a, min_b_for_a).into_val(&env),
        );
        b.require_auth_for_args(
            (token_b.clone(), token_a.clone(), amount_b, min_a_for_b).into_val(&env),
        );

        // Perform the swap by moving tokens from a to b and from b to a.
        move_token(&env, &token_a, &a, &b, amount_a, min_a_for_b);
        move_token(&env, &token_b, &b, &a, amount_b, min_b_for_a);
    }

fn move_token(
    env: &Env,
    token: &Address,
    from: &Address,
    to: &Address,
    max_spend_amount: i128,
    transfer_amount: i128,
) {
    let token = token::Client::new(env, token);
    let contract_address = env.current_contract_address();
    // This call needs to be authorized by `from` address. It transfers the
    // maximum spend amount to the swap contract's address in order to decouple
    // the signature from `to` address (so that parties don't need to know each
    // other).
    token.transfer(from, &contract_address, &max_spend_amount);
    // Transfer the necessary amount to `to`.
    token.transfer(&contract_address, to, &transfer_amount);
    // Refund the remaining balance to `from`.
    token.transfer(
        &contract_address,
        from,
        &(max_spend_amount - transfer_amount),
    );}

mod test;
",
    "completion": "#![cfg(test)]
extern crate std;

use super::*;
use soroban_sdk::{
    symbol_short,
    testutils::{Address as _, AuthorizedFunction, AuthorizedInvocation},
    token, Address, Env, IntoVal,
};
use token::Client as TokenClient;
use token::StellarAssetClient as TokenAdminClient;

fn create_token_contract<'a>(e: &Env, admin: &Address) -> (TokenClient<'a>, TokenAdminClient<'a>) {
    let sac = e.register_stellar_asset_contract_v2(admin.clone());
    (
        token::Client::new(e, &sac.address()),
        token::StellarAssetClient::new(e, &sac.address()),
    )}

fn create_atomic_swap_contract(e: &Env) -> AtomicSwapContractClient {
    AtomicSwapContractClient::new(e, &e.register_contract(None, AtomicSwapContract {}))}

#[test]
fn test_atomic_swap() {
    let env = Env::default();
    env.mock_all_auths();

    let a = Address::generate(&env);
    let b = Address::generate(&env);

    let token_admin = Address::generate(&env);

    let (token_a, token_a_admin) = create_token_contract(&env, &token_admin);
    let (token_b, token_b_admin) = create_token_contract(&env, &token_admin);
    token_a_admin.mint(&a, &1000);
    token_b_admin.mint(&b, &5000);

    let contract = create_atomic_swap_contract(&env);

    contract.swap(
        &a,
        &b,
        &token_a.address,
        &token_b.address,
        &1000,
        &4500,
        &5000,
        &950,
    );

    assert_eq!(
        env.auths(),
        std::vec![
            (
                a.clone(),
                AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        contract.address.clone(),
                        symbol_short!("swap"),
                        (
                            token_a.address.clone(),
                            token_b.address.clone(),
                            1000_i128,
                            4500_i128
                        )
                            .into_val(&env),
                    )),
                    sub_invocations: std::vec![AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token_a.address.clone(),
                            symbol_short!("transfer"),
                            (a.clone(), contract.address.clone(), 1000_i128,).into_val(&env),
                        )),
                        sub_invocations: std::vec![]
                    }]
                }
            ),
            (
                b.clone(),
                AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        contract.address.clone(),
                        symbol_short!("swap"),
                        (
                            token_b.address.clone(),
                            token_a.address.clone(),
                            5000_i128,
                            950_i128
                        )
                            .into_val(&env),
                    )),
                    sub_invocations: std::vec![AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token_b.address.clone(),
                            symbol_short!("transfer"),
                            (b.clone(), contract.address.clone(), 5000_i128,).into_val(&env),
                        )),
                        sub_invocations: std::vec![]
                    }]
                }
            ),
        ]
    );

    assert_eq!(token_a.balance(&a), 50);
    assert_eq!(token_a.balance(&b), 950);

    assert_eq!(token_b.balance(&a), 4500);
    assert_eq!(token_b.balance(&b), 500);}
"
  }
  {
    "prompt": "//! This contract demonstrates how to implement authorization using
//! Soroban-managed auth framework for a simple case (a single user that needs
//! to authorize a single contract invocation).
//!
//! See `timelock` and `single_offer` examples for demonstration of performing
//! authorized token operations on behalf of the user.
//!
//! See `atomic_swap` and `atomic_multiswap` examples for demonstration of
//! multi-party authorizaton.
//!
//! See `account` example for demonstration of an acount contract with
//! a custom authentication scheme and a custom authorization policy.
#![no_std]
use soroban_sdk::{contract, contractimpl, contracttype, Address, Env};

#[contracttype]
pub enum DataKey {
    Counter(Address),}

#[contract]
pub struct IncrementContract;

#[contractimpl]
impl IncrementContract {
    /// Increment increments a counter for the user, and returns the value.
    pub fn increment(env: Env, user: Address, value: u32) -> u32 {
        // Requires `user` to have authorized call of the `increment` of this
        // contract with all the arguments passed to `increment`, i.e. `user`
        // and `value`. This will panic if auth fails for any reason.
        // When this is called, Soroban host performs the necessary
        // authentication, manages replay prevention and enforces the user's
        // authorization policies.
        // The contracts normally shouldn't worry about these details and just
        // write code in generic fashion using `Address` and `require_auth` (or
        // `require_auth_for_args`).
        user.require_auth();

        // This call is equilvalent to the above:
        // user.require_auth_for_args((&user, value).into_val(&env));

        // The following has less arguments but is equivalent in authorization
        // scope to the above calls (the user address doesn't have to be
        // included in args as it's guaranteed to be authenticated).
        // user.require_auth_for_args((value,).into_val(&env));

        // Construct a key for the data being stored. Use an enum to set the
        // contract up well for adding other types of data to be stored.
        let key = DataKey::Counter(user.clone());

        // Get the current count for the invoker.
        let mut count: u32 = env.storage().persistent().get(&key).unwrap_or_default();

        // Increment the count.
        count += value;

        // Save the count.
        env.storage().persistent().set(&key, &count);

        // Return the count to the caller.
        count
    }

mod test;
",
    "completion": "#![cfg(test)]
extern crate std;

use soroban_sdk::{
    symbol_short,
    testutils::{Address as _, AuthorizedFunction, AuthorizedInvocation},
    Address, Env, IntoVal,
};

use crate::{IncrementContract, IncrementContractClient};

#[test]
fn test() {
    let env = Env::default();
    env.mock_all_auths();

    let contract_id = env.register_contract(None, IncrementContract);
    let client = IncrementContractClient::new(&env, &contract_id);

    let user_1 = Address::generate(&env);
    let user_2 = Address::generate(&env);

    assert_eq!(client.increment(&user_1, &5), 5);
    // Verify that the user indeed had to authorize a call of `increment` with
    // the expected arguments:
    assert_eq!(
        env.auths(),
        std::vec![(
            // Address for which authorization check is performed
            user_1.clone(),
            // Invocation tree that needs to be authorized
            AuthorizedInvocation {
                // Function that is authorized. Can be a contract function or
                // a host function that requires authorization.
                function: AuthorizedFunction::Contract((
                    // Address of the called contract
                    contract_id.clone(),
                    // Name of the called function
                    symbol_short!("increment"),
                    // Arguments used to call `increment` (converted to the env-managed vector via `into_val`)
                    (user_1.clone(), 5_u32).into_val(&env),
                )),
                // The contract doesn't call any other contracts that require
                // authorization,
                sub_invocations: std::vec![]
            }
        )]
    );

    // Do more `increment` calls. It's not necessary to verify authorizations
    // for every one of them as we don't expect the auth logic to change from
    // call to call.
    assert_eq!(client.increment(&user_1, &2), 7);
    assert_eq!(client.increment(&user_2, &1), 1);
    assert_eq!(client.increment(&user_1, &3), 10);
    assert_eq!(client.increment(&user_2, &4), 5);}
"
  }
  {
    "prompt": "Contract a: #![no_std]

use soroban_sdk::{contract, contractimpl};

#[contract]
pub struct ContractA;

#[contractimpl]
impl ContractA {
    pub fn add(x: u32, y: u32) -> u32 {
        x.checked_add(y).expect("no overflow")
    }
} y el contract b: #![no_std]

use soroban_sdk::{contract, contractimpl, Address, Env};

mod contract_a {
    soroban_sdk::contractimport!(
        file = "../contract_a/target/wasm32-unknown-unknown/release/soroban_cross_contract_a_contract.wasm"
    );}

#[contract]
pub struct ContractB;

#[contractimpl]
impl ContractB {
    pub fn add_with(env: Env, contract: Address, x: u32, y: u32) -> u32 {
        let client = contract_a::Client::new(&env, &contract);
        client.add(&x, &y)
    }

mod test;
",
    "completion": "#![cfg(test)]

use crate::{contract_a, ContractB, ContractBClient};
use soroban_sdk::Env;

#[test]
fn test() {
    let env = Env::default();

    // Register contract A using the imported WASM.
    let contract_a_id = env.register_contract_wasm(None, contract_a::WASM);

    // Register contract B defined in this crate.
    let contract_b_id = env.register_contract(None, ContractB);

    // Create a client for calling contract B.
    let client = ContractBClient::new(&env, &contract_b_id);

    // Invoke contract B via its client. Contract B will invoke contract A.
    let sum = client.add_with(&contract_a_id, &5, &7);
    assert_eq!(sum, 12);}
"
  }
  {
    "prompt": "#![no_std]
use soroban_sdk::{contract, contractimpl, contracttype, symbol_short, Env, Symbol};

#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct State {
    pub count: u32,
    pub last_incr: u32,}

const STATE: Symbol = symbol_short!("STATE");

#[contract]
pub struct IncrementContract;

#[contractimpl]
impl IncrementContract {
    /// Increment increments an internal counter, and returns the value.
    pub fn increment(env: Env, incr: u32) -> u32 {
        // Get the current count.
        let mut state = Self::get_state(env.clone());

        // Increment the count.
        state.count += incr;
        state.last_incr = incr;

        // Save the count.
        env.storage().instance().set(&STATE, &state);

        // Return the count to the caller.
        state.count
    }
    /// Return the current state.
    pub fn get_state(env: Env) -> State {
        env.storage().instance().get(&STATE).unwrap_or(State {
            count: 0,
            last_incr: 0,
        }) // If no value set, assume 0.
    }

mod test;
",
    "completion": "#![cfg(test)]

use super::*;
use soroban_sdk::Env;

#[test]
fn test() {
    let env = Env::default();
    let contract_id = env.register_contract(None, IncrementContract);
    let client = IncrementContractClient::new(&env, &contract_id);

    assert_eq!(client.increment(&1), 1);
    assert_eq!(client.increment(&10), 11);
    assert_eq!(
        client.get_state(),
        State {
            count: 11,
            last_incr: 10
        }
    );}
"
  }
  {
    "prompt": "#![no_std]
/// This example demonstrates how a contract can authorize deep subcontract
/// calls on its behalf.
///
/// By default, only direct calls that contract makes are authorized. However,
/// in some scenarios one may want to authorize a deeper call (a common example
/// would be token transfer).
///
/// Here we provide the abstract example: contract A calls contract B, then
/// contract B calls contract C. Both contract B and contract C `require_auth`
/// for contract A address and contract A provides proper authorization to make
/// the calls succeed.

pub mod contract_a {

    use soroban_sdk::{
        auth::{ContractContext, InvokerContractAuthEntry, SubContractInvocation},
        contract, contractimpl, vec, Address, Env, IntoVal, Symbol,
    };

    use crate::contract_b::ContractBClient;

    #[contract]
    pub struct ContractA;

    #[contractimpl]
    impl ContractA {
        pub fn call_b(env: Env, contract_b_address: Address, contract_c_address: Address) {
            // This function authorizes sub-contract calls that are made from
            // the next call A performs on behalf of the current contract.
            // Note, that these *do not* contain direct calls because they are
            // always authorized. So here we pre-authorize call of contract C
            // that will be performed by contract B.
            env.authorize_as_current_contract(vec![
                &env,
                InvokerContractAuthEntry::Contract(SubContractInvocation {
                    context: ContractContext {
                        contract: contract_c_address.clone(),
                        fn_name: Symbol::new(&env, "authorized_fn_c"),
                        args: (env.current_contract_address(),).into_val(&env),
                    },
                    // `sub_invocations` can be used to authorize even deeper
                    // calls.
                    sub_invocations: vec![&env],
                }),
            ]);
            let client = ContractBClient::new(&env, &contract_b_address);
            client.authorized_fn_b(&env.current_contract_address(), &contract_c_address);
        }
    }

pub mod contract_b {
    use soroban_sdk::{contract, contractimpl, Address, Env};

    use crate::contract_c::ContractCClient;

    #[contract]
    pub struct ContractB;

    #[contractimpl]
    impl ContractB {
        pub fn authorized_fn_b(env: Env, authorizer: Address, contract_c_address: Address) {
            authorizer.require_auth();
            let client = ContractCClient::new(&env, &contract_c_address);
            client.authorized_fn_c(&authorizer);
        }
    }

pub mod contract_c {

    use soroban_sdk::{contract, contractimpl, Address, Env};

    #[contract]
    pub struct ContractC;

    #[contractimpl]
    impl ContractC {
        pub fn authorized_fn_c(_env: Env, authorizer: Address) {
            authorizer.require_auth();
        }
    }

mod test;
",
    "completion": "#![cfg(test)]

use soroban_sdk::Env;

use crate::{
    contract_a::{ContractA, ContractAClient},
    contract_b::ContractB,
    contract_c::ContractC,
};
extern crate std;

#[test]
fn test() {
    let env = Env::default();
    let a_address = env.register_contract(None, ContractA);
    let b_address = env.register_contract(None, ContractB);
    let c_address = env.register_contract(None, ContractC);
    let client = ContractAClient::new(&env, &a_address);
    client.call_b(&b_address, &c_address);}
"
  }
  {
    "prompt": "contract: #![no_std]

use soroban_sdk::{contract, contractimpl, symbol_short, Env, Symbol};

#[contract]
pub struct Contract;

const KEY: Symbol = symbol_short!("value");

#[contractimpl]
impl Contract {
    pub fn init(env: Env, value: u32) {
        env.storage().instance().set(&KEY, &value);
    }
    pub fn value(env: Env) -> u32 {
        env.storage().instance().get(&KEY).unwrap()
    }
y deployer:
#![no_std]

use soroban_sdk::{contract, contractimpl, Address, BytesN, Env, Symbol, Val, Vec};

#[contract]
pub struct Deployer;

#[contractimpl]
impl Deployer {
    /// Deploy the contract Wasm and after deployment invoke the init function
    /// of the contract with the given arguments.
    ///
    /// This has to be authorized by `deployer` (unless the `Deployer` instance
    /// itself is used as deployer). This way the whole operation is atomic
    /// and it's not possible to frontrun the contract initialization.
    ///
    /// Returns the contract ID and result of the init function.
    pub fn deploy(
        env: Env,
        deployer: Address,
        wasm_hash: BytesN<32>,
        salt: BytesN<32>,
        init_fn: Symbol,
        init_args: Vec<Val>,
    ) -> (Address, Val) {
        // Skip authorization if deployer is the current contract.
        if deployer != env.current_contract_address() {
            deployer.require_auth();
        }

        // Deploy the contract using the uploaded Wasm with given hash.
        let deployed_address = env
            .deployer()
            .with_address(deployer, salt)
            .deploy(wasm_hash);

        // Invoke the init function with the given arguments.
        let res: Val = env.invoke_contract(&deployed_address, &init_fn, init_args);
        // Return the contract ID of the deployed contract and the result of
        // invoking the init result.
        (deployed_address, res)
    }

mod test;

",
    "completion": "#![cfg(test)]
extern crate alloc;
extern crate std;

use crate::{Deployer, DeployerClient};
use alloc::vec;
use soroban_sdk::{
    symbol_short,
    testutils::{Address as _, AuthorizedFunction, AuthorizedInvocation},
    xdr::{self, ContractIdPreimage, ContractIdPreimageFromAddress, CreateContractArgs, Uint256},
    Address, BytesN, Env, IntoVal, Val, Vec,
};

// The contract that will be deployed by the deployer contract.
mod contract {
    soroban_sdk::contractimport!(
        file =
            "../contract/target/wasm32-unknown-unknown/release/soroban_deployer_test_contract.wasm"
    );}

#[test]
fn test_deploy_from_contract() {
    let env = Env::default();
    let deployer_client = DeployerClient::new(&env, &env.register_contract(None, Deployer));

    // Upload the Wasm to be deployed from the deployer contract.
    // This can also be called from within a contract if needed.
    let wasm_hash = env.deployer().upload_contract_wasm(contract::WASM);

    // Deploy contract using deployer, and include an init function to call.
    let salt = BytesN::from_array(&env, &[0; 32]);
    let init_fn = symbol_short!("init");
    let init_fn_args: Vec<Val> = (5u32,).into_val(&env);
    env.mock_all_auths();
    let (contract_id, init_result) = deployer_client.deploy(
        &deployer_client.address,
        &wasm_hash,
        &salt,
        &init_fn,
        &init_fn_args,
    );

    assert!(init_result.is_void());
    // No authorizations needed - the contract acts as a factory.
    assert_eq!(env.auths(), vec![]);

    // Invoke contract to check that it is initialized.
    let client = contract::Client::new(&env, &contract_id);
    let sum = client.value();
    assert_eq!(sum, 5);}

#[test]
fn test_deploy_from_address() {
    let env = Env::default();
    let deployer_client = DeployerClient::new(&env, &env.register_contract(None, Deployer));

    // Upload the Wasm to be deployed from the deployer contract.
    // This can also be called from within a contract if needed.
    let wasm_hash = env.deployer().upload_contract_wasm(contract::WASM);

    // Define a deployer address that needs to authorize the deployment.
    let deployer = Address::generate(&env);

    // Deploy contract using deployer, and include an init function to call.
    let salt = BytesN::from_array(&env, &[0; 32]);
    let init_fn = symbol_short!("init");
    let init_fn_args: Vec<Val> = (5u32,).into_val(&env);
    env.mock_all_auths();
    let (contract_id, init_result) =
        deployer_client.deploy(&deployer, &wasm_hash, &salt, &init_fn, &init_fn_args);

    assert!(init_result.is_void());

    let expected_auth = AuthorizedInvocation {
        // Top-level authorized function is `deploy` with all the arguments.
        function: AuthorizedFunction::Contract((
            deployer_client.address,
            symbol_short!("deploy"),
            (
                deployer.clone(),
                wasm_hash.clone(),
                salt,
                init_fn,
                init_fn_args,
            )
                .into_val(&env),
        )),
        // From `deploy` function the 'create contract' host function has to be
        // authorized.
        sub_invocations: vec![AuthorizedInvocation {
            function: AuthorizedFunction::CreateContractHostFn(CreateContractArgs {
                contract_id_preimage: ContractIdPreimage::Address(ContractIdPreimageFromAddress {
                    address: deployer.clone().try_into().unwrap(),
                    salt: Uint256([0; 32]),
                }),
                executable: xdr::ContractExecutable::Wasm(xdr::Hash(wasm_hash.into_val(&env))),
            }),
            sub_invocations: vec![],
        }],
    };
    assert_eq!(env.auths(), vec![(deployer, expected_auth)]);

    // Invoke contract to check that it is initialized.
    let client = contract::Client::new(&env, &contract_id);
    let sum = client.value();
    assert_eq!(sum, 5);}
"
  }
  
  {
    "prompt": "#![no_std]
use soroban_sdk::{contract, contracterror, contractimpl, log, symbol_short, Env, Symbol};

#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum Error {
    LimitReached = 1,}

const COUNTER: Symbol = symbol_short!("COUNTER");
const MAX: u32 = 5;

#[contract]
pub struct IncrementContract;

#[contractimpl]
impl IncrementContract {
    /// Increment increments an internal counter, and returns the value. Errors
    /// if the value is attempted to be incremented past 5.
    pub fn increment(env: Env) -> Result<u32, Error> {
        // Get the current count.
        let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0); // If no value set, assume 0.
        log!(&env, "count: {}", count);

        // Increment the count.
        count += 1;

        // Check if the count exceeds the max.
        if count <= MAX {
            // Save the count.
            env.storage().instance().set(&COUNTER, &count);

            // Return the count to the caller.
            Ok(count)
        } else {
            // Return an error if the max is exceeded.
            Err(Error::LimitReached)
        }
    }

mod test;
",
    "completion": "#![cfg(test)]

use super::*;
use soroban_sdk::{testutils::Logs, Env};

extern crate std;

#[test]
fn test() {
    let env = Env::default();
    let contract_id = env.register_contract(None, IncrementContract);
    let client = IncrementContractClient::new(&env, &contract_id);

    assert_eq!(client.try_increment(), Ok(Ok(1)));
    assert_eq!(client.try_increment(), Ok(Ok(2)));
    assert_eq!(client.try_increment(), Ok(Ok(3)));
    assert_eq!(client.try_increment(), Ok(Ok(4)));
    assert_eq!(client.try_increment(), Ok(Ok(5)));
    assert_eq!(client.try_increment(), Err(Ok(Error::LimitReached)));

    std::println!("{}", env.logs().all().join("\n"));}

#[test]
#[should_panic(expected = "HostError: Error(Contract, #1)")]
fn test_panic() {
    let env = Env::default();
    let contract_id = env.register_contract(None, IncrementContract);
    let client = IncrementContractClient::new(&env, &contract_id);

    assert_eq!(client.increment(), 1);
    assert_eq!(client.increment(), 2);
    assert_eq!(client.increment(), 3);
    assert_eq!(client.increment(), 4);
    assert_eq!(client.increment(), 5);
    client.increment();}
"
  }
}
